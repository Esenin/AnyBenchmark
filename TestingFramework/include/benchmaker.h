#pragma once#include <string>#include <functional>#include <vector>#include "constants.h"#include "iTestObject.h"#include "../src/pipelineHandlers/pipelineHolder.h"namespace benchmark{//! @class Benchmaker makes tests routine measuring average time for testclass Benchmaker{public:    Benchmaker();    ~Benchmaker();    //! @arg count shows how much repeats of single test will be done to get average value    //! please consider that it will be at least one warmup iteration    void setRoundsCount(unsigned int const &count = 10);    //! @brief see enum @class MeasureType    void setMeasureType(MeasureType measureType);    //! @arg object is a subject that will be tested    void setRunnableObject(ITestObject *object);    typedef std::function<std::pair<bool, int> (void)>  ParamGenerator;    void setTestingParam(int const x);    //! @brief loop with @attention increasing params    //! @arg from is start param "N"    //! @arg to   is max bound of tests    //! @arg step is a positive difference between each test    void setTestingParam(int from, int to, int step = 1);    void setTestingParam(std::initializer_list<int> list);    //! @return (true, N) as next testing param or (false, .) if there are no more testing params    void setTestingParam(ParamGenerator paramYielder);    //! @arg name is prefix of filename with tests result    //! must be called After setting new runnable object    void setBenchmarkName(std::string const &name);    //! @arg mustLog switches mode of logging to file    void setLogginToFile(FileOutput const format);    //! @brief if subject's run() methods repeats action N times, you can set N as value of division    //!        factor. So all results will be divided at this value.    //! @attention set value = 0 to turn off any division in post-processing    //! @arg value division factor for results    void setDivisionFactor(size_t value);    //! @brief consider benchmarks set as a single group (e.g. to place together in same CSV)    //! no nesting groups available now    void beginGroup();    //! @brief end of benchmark group    void endGroup();    //! @brief start benchmark on given object    //! @return average amount of milliseconds that consumes testing subject for run() method    ResultsQueue makeBenchmark();private:    FileOutput mFileFormat;    MeasureType mMeasureType;    int mGroupId;    int mRoundsCount;    size_t mDivisionFactor;    std::string mBenchmarkName;    std::string mResultsFilename;    ITestObject *mTestObj;    benchmark::impl::PipelineHolder mPipeline;    ParamGenerator mParamGenerator;    std::vector<int> mParamList; //< could be unused    ResultsQueue mBenchmarkResults;    //! makes preparation before- and cleaning after test    //! @return time per test in [ms]    long makeRound(int const &paramN);    //! runs single test    //! @return elapsed time in [ms]    long makeTest();    void configureBenchmark();    void freeTestObject();    std::string constructFilename() const;    std::string getTimeString() const;};} // benchmark